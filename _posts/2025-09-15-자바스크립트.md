---
title: "비교연산자 /"
excerpt: ""

categories:
  - javascript

tags:
  - [javascript]

toc: true
toc_sticky: true

date: 2025-09-15
last_modified_at: 2025-09-15

description: 
---

# 🔴 이 글을 쓰기 위해 참고한 영상 / 사이트

[[사이트]모던 자바스크립트](https://ko.javascript.info/intro)

## 🟠 비교연산자
저번 기본 연산자에 이어 비교 연산자에 대해 살펴보자면, 

뭐 여기에도 기초적인 비교 연산자가 있다. ( 크다 작다 크거나 같다 작거나 같다 등 ) 
- 동등하다 == ( = 하나는 할당을 의미하기에 다른 의미이다. ) 
- 같지 않다 ≠ ( ! = ) 

이러한 비교 연산자는 최종적으로 값을 반환하게 되는데, 그 값은 불린형이다.  
비교 연산자라고 하면 수학적으로 보아 숫자만 비교할 수 있다 생각할 수 있지만, 그렇지만도 않다.

### 🟡 문자열 비교  
JS 에서는 문자열을 비교할 때 ‘사전’ 순으로 비교를 거치게 된다. 
사전이라고는 하지만, 정확히는 유니코드 순이라고 생각하면 좋다.  

이 문자열 비교에는 규칙이 존재하는데, 
1. 두 문자열의 첫 글자를 비교한다. 
2. 첫 글자가 다른 문자열의 첫 글자와 비교를 하여, 크고 작음을 보고 여기서 걸러지면 종료. 
3. 첫 글자가 같은 경우, 그 다음 글자를 비교한다. ( 글자가 다를 때까지 비교, 대소문자 구분함 ) 
4. 모두 같은 경우, 두 문자열은 같다고 결론내린다. 
5. 만약, 두 같은 문자열 중 하나가 더 긴 문자열이라면 긴 문자열을 크다고 인식함. 

글자 순이라는건, 더 정확히는  
”2” 와 “12”를 비교하자면
”2”와 “12”의 첫 글자인 “1”을 먼저 비교한다는 의미이다. 

### 🟡 다른 형을 가진 값 비교   
JS에서는 비교하려는 값이 서로 다를 경우, 숫자형으로 변환하고 비교를 거치게 된다.   
alert(’01’ == 1); // true  
문자열 01은 숫자 1로 변환 후 비교를 거치게 됨.   
불린의 경우 true 는 1, false는 0  


### 🟡 명시적 변환을 통한
Boolean() 을 통한 명시적인 변환을 통해 논리적인 평가를 거치면, 
문자열에서 숫자로 변환 후랑 처음부터 숫자형인 것을 결론지으면 서로 다른 규칙이 적용되나보다. 

문자열 “0” 은 Boolean() 으로 true, 숫자 0은 false 가 나오기 때문. 

### 🟡 일치 연산자 
동등 연산자 == 은 0과 false를 구별하지 못한다. 
이를 테면, 0 == false 는 논리 연산을 통하면 
false를 숫자형으로 바꾸기에 0 == 0 으로 알아들어 true를 반환하게 된다. 
이는 빈 문자열에서도 마찬가지이다. 

일치 연산자 === 는 형 변환 없이 값을 비교할 수 있게 해준다. 
엄격한 연산자이기 때문에, 비교하는 서로 형이 다를 경우 바로 false를 반환한다. 

반대는 불일치 연산자 ! == 
그리고 부등 연산자 ! = 이다. 

### 🟡 null 및 undefined 비교
null이나 undefined 를 각각 연산자로 비교하면 다음과 같다. 

( 일치 연산자 )  
null === undefined // false 자료형이 다르기 때문

( 동등 연산자 )  
null == undefined // true 특별한 규칙에 따름

( 이외 산술 연산자 )   
산술 연산자에서는 각각 숫자로 변환한다. 
null 은 0, undefined 는 NaN으로 변환된다. 

사실, null 이나 undefined 는 의도된 것이 아니라면 
비교를 하지 않는 것을 추천한다고 한다. 

이례적인 규칙이 너무 많기 때문이기도 하고, 그럴 일도 흔하지 않기 때문이다.  



